import{ap as x,cl as Q,r as m,c as R,a2 as d,a4 as j,a5 as z,h as O,cm as U,o as F,ar as W,cn as G,at as _,au as J,co as h,cp as E,cq as k,cr as q,cs as P,ct as K,cu as X,l as Y,a9 as Z,R as ee,n as te,v as A,x as H,w as le,t as se,cv as ae,p as ne,q as oe}from"./index-D_pQv8pS.js";const{passive:r}=U,re=x({name:"QInfiniteScroll",props:{offset:{type:Number,default:500},debounce:{type:[String,Number],default:100},scrollTarget:Q,initialIndex:{type:Number,default:0},disable:Boolean,reverse:Boolean},emits:["load"],setup(s,{slots:v,emit:b}){const n=m(!1),l=m(!0),i=m(null),g=m(null);let u=s.initialIndex,e,a;const w=R(()=>"q-infinite-scroll__loading"+(n.value===!0?"":" invisible"));function c(){if(s.disable===!0||n.value===!0||l.value===!1)return;const t=h(e),o=E(e),f=k(e);s.reverse===!1?Math.round(o+f+s.offset)>=Math.round(t)&&S():Math.round(o)<=s.offset&&S()}function S(){if(s.disable===!0||n.value===!0||l.value===!1)return;u++,n.value=!0;const t=h(e);b("load",u,o=>{l.value===!0&&(n.value=!1,q(()=>{if(s.reverse===!0){const f=h(e),V=E(e),$=f-t;P(e,V+$)}o===!0?p():i.value&&i.value.closest("body")&&a()}))})}function C(){u=0}function L(){l.value===!1&&(l.value=!0,e.addEventListener("scroll",a,r)),c()}function p(){l.value===!0&&(l.value=!1,n.value=!1,e.removeEventListener("scroll",a,r),a?.cancel?.())}function y(){if(e&&l.value===!0&&e.removeEventListener("scroll",a,r),e=K(i.value,s.scrollTarget),l.value===!0){if(e.addEventListener("scroll",a,r),s.reverse===!0){const t=h(e),o=k(e);P(e,t-o)}c()}}function D(t){u=t}function N(t){t=parseInt(t,10);const o=a;a=t<=0?c:X(c,isNaN(t)===!0?100:t),e&&l.value===!0&&(o!==void 0&&e.removeEventListener("scroll",o,r),e.addEventListener("scroll",a,r))}function I(t){if(T.value===!0){if(g.value===null){t!==!0&&q(()=>{I(!0)});return}const o=`${n.value===!0?"un":""}pauseAnimations`;Array.from(g.value.getElementsByTagName("svg")).forEach(f=>{f[o]()})}}const T=R(()=>s.disable!==!0&&l.value===!0);d([n,T],()=>{I()}),d(()=>s.disable,t=>{t===!0?p():L()}),d(()=>s.reverse,()=>{n.value===!1&&l.value===!0&&c()}),d(()=>s.scrollTarget,y),d(()=>s.debounce,N);let B=!1;j(()=>{B!==!1&&e&&P(e,B)}),z(()=>{B=e?E(e):!1}),O(()=>{l.value===!0&&e.removeEventListener("scroll",a,r)}),F(()=>{N(s.debounce),y(),n.value===!1&&I()});const M=W();return Object.assign(M.proxy,{poll:()=>{a?.()},trigger:S,stop:p,reset:C,resume:L,setIndex:D,updateScrollTarget:y}),()=>{const t=G(v.default,[]);return T.value===!0&&t[s.reverse===!1?"push":"unshift"](_("div",{ref:g,class:w.value},J(v.loading))),_("div",{class:"q-infinite-scroll",ref:i},t)}}}),ie={class:"row justify-center"},ce=Y({__name:"BaseInfiniteScroll",props:{scrollTarget:{},reverse:{type:Boolean,default:!1},debounce:{default:250},offset:{default:500},disable:{type:Boolean,default:!1}},emits:["on-infinite"],setup(s,{expose:v,emit:b}){const n=b,l=Z("baseInfiniteScrollRef"),i=(e,a)=>{n("on-infinite",e,a)};return v({stop:()=>{l.value&&l.value.stop()},resume:()=>{l.value&&l.value.resume()}}),(e,a)=>(te(),ee("div",ne(oe(e.$attrs)),[A(e.$slots,"default"),H(re,{ref_key:"baseInfiniteScrollRef",ref:l,reverse:e.reverse,offset:e.offset,debounce:e.debounce,disable:e.disable,"scroll-target":e.scrollTarget,onLoad:i},{loading:le(()=>[se("div",ie,[H(ae,{color:"primary",size:"2em",class:"self-center"})])]),_:1},8,["reverse","offset","debounce","disable","scroll-target"]),A(e.$slots,"bottom")],16))}});export{ce as _};
